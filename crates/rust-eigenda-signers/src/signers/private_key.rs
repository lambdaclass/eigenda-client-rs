use async_trait::async_trait;
use secp256k1::{self, SECP256K1};
use thiserror::Error;

use crate::{
    InvalidRecoveryId, Message, PublicKey, RecoverableSignature, RecoveryId, SecretKey, Sign,
};

/// Errors that can occur during private key signing or key handling.
#[derive(Error, Debug, PartialEq, Eq)]
pub enum Error {
    /// Indicates an invalid recovery ID was encountered during signature conversion.
    /// This should theoretically not happen with signatures generated by secp256k1.
    #[error(transparent)]
    InvalidRecoveryId(#[from] InvalidRecoveryId),
}

/// A signer that uses a local private key stored in memory.
#[derive(Clone, Debug)]
pub struct Signer {
    secret_key: ::secp256k1::SecretKey,
}

impl Signer {
    /// Creates a new signer from our SecretKey type.
    pub fn new(secret_key: SecretKey) -> Self {
        Self {
            secret_key: secret_key.into(),
        }
    }

    /// Creates a new signer with a randomly generated private key.
    pub fn random<R: rand::Rng + ?Sized>(rng: &mut R) -> Self {
        let (secret_key, _) = SECP256K1.generate_keypair(rng);
        Self { secret_key }
    }

    /// Returns the secret key
    pub fn secret_key(&self) -> SecretKey {
        self.secret_key.into()
    }
}

impl TryFrom<::secp256k1::ecdsa::RecoverableSignature> for RecoverableSignature {
    type Error = InvalidRecoveryId;
    fn try_from(sig: ::secp256k1::ecdsa::RecoverableSignature) -> Result<Self, Self::Error> {
        let (recid, rs) = sig.serialize_compact();
        let mut r = [0u8; 32];
        let mut s = [0u8; 32];
        r.copy_from_slice(&rs[0..32]);
        s.copy_from_slice(&rs[32..64]);

        let recid: u8 = recid
            .to_i32()
            .try_into()
            .expect("secp256k1 recoveryid is strictly 0..=3, i.e. fits in u8");

        let v = RecoveryId::try_from(recid)?;

        Ok(RecoverableSignature { r, s, v })
    }
}

impl TryFrom<RecoverableSignature> for ::secp256k1::ecdsa::RecoverableSignature {
    type Error = ::secp256k1::Error;

    fn try_from(sig: RecoverableSignature) -> Result<Self, Self::Error> {
        let recid = ::secp256k1::ecdsa::RecoveryId::from_i32(sig.v.to_byte() as i32)?;

        let mut rs = [0u8; 64];
        rs[0..32].copy_from_slice(&sig.r);
        rs[32..64].copy_from_slice(&sig.s);

        ::secp256k1::ecdsa::RecoverableSignature::from_compact(&rs, recid)
    }
}

#[async_trait]
impl Sign for Signer {
    type Error = Error;

    async fn sign_digest(&self, message: &Message) -> Result<RecoverableSignature, Self::Error> {
        let sk = self.secret_key;

        let signature = SECP256K1
            .sign_ecdsa_recoverable(&(*message).into(), &sk)
            .try_into()?;

        Ok(signature)
    }

    /// Returns the public key associated with this signer.
    fn public_key(&self) -> PublicKey {
        SecretKey::from(self.secret_key).public_key()
    }
}

#[cfg(test)]
mod tests {
    use rand::thread_rng;
    use secp256k1::{self, ecdsa as secp_ecdsa, SECP256K1};
    use tokio;

    use super::Signer;
    use crate::{Message, RecoverableSignature, SecretKey, Sign};

    #[tokio::test]
    async fn test_local_signer_sign_and_verify() {
        // given
        let signer = Signer::random(&mut thread_rng());
        let our_public_key = signer.public_key();
        // Reconstruct secp key for verification
        let secp_secret_key =
            secp256k1::SecretKey::from_slice(&signer.secret_key().secret_bytes()).unwrap();
        let secp_public_key = secp256k1::PublicKey::from_secret_key(SECP256K1, &secp_secret_key);

        let message_bytes = b"Test message for local signer";
        let digest = crate::public_key::keccak256(message_bytes);
        let message = Message::new(digest);

        // when
        let our_recoverable_sig: RecoverableSignature = signer
            .sign_digest(&message)
            .await
            .expect("Signing failed unexpectedly");

        // then
        let secp_message = secp256k1::Message::from_slice(message.as_bytes()).unwrap();
        let secp_sig = secp256k1::ecdsa::RecoverableSignature::try_from(our_recoverable_sig)
            .expect("Could not convert back to secp signature");
        let recovered_pk = SECP256K1
            .recover_ecdsa(&secp_message, &secp_sig)
            .expect("Recovery failed");

        // Assert that the recovered secp key matches the original secp key
        assert_eq!(
            recovered_pk, secp_public_key,
            "Recovered secp public key mismatch"
        );
        assert_eq!(
            our_public_key.serialize_uncompressed(),
            secp_public_key.serialize_uncompressed(),
            "Byte representation mismatch"
        );
    }

    #[test]
    fn test_local_signer_address() {
        // given
        // Create our SecretKey first
        let key_bytes =
            hex::decode("856f2fd4e3ff354a7f43680d6d9da56390184b43ec63beb06b66c9fd1bc79858")
                .unwrap()
                .try_into()
                .unwrap();
        let key = SecretKey::new(key_bytes).expect("Failed to create secret key from valid hex");
        let signer = Signer::new(key);

        // when
        // public_key() now returns Result
        let address = signer.public_key().address();

        // then
        let expected_address = "0x08AbDA505838eb8929c2c1cABD7E1c26e4BA94e1"
            .parse()
            .unwrap();

        assert_eq!(address, expected_address, "Ethereum address mismatch");
    }

    #[test]
    fn test_signer_new() {
        // Given
        let sk_bytes = [1u8; 32];
        let sk = SecretKey::new(sk_bytes).unwrap();

        // When
        let signer = Signer::new(sk);

        // Then
        assert_eq!(signer.secret_key(), sk);
    }

    // Just to add extra protection against regressions. The fact that the recovery id is <=
    // u8::MAX is used in a TryFrom implementation
    #[test]
    fn test_secp_recovery_id_range() {
        // Verify that secp256k1::ecdsa::RecoveryId::from_i32 only accepts 0, 1, 2, 3
        for i in 0..=3 {
            let recid = secp_ecdsa::RecoveryId::from_i32(i)
                .unwrap_or_else(|_| panic!("Failed to create RecoveryId from valid i32: {}", i));
            assert_eq!(recid.to_i32(), i, "Mismatch after creating from valid i32");
        }

        // Verify values outside 0..=3 fail
        assert!(secp_ecdsa::RecoveryId::from_i32(-1).is_err());
        assert!(secp_ecdsa::RecoveryId::from_i32(4).is_err());
    }
}
